## 1. 형상관리 시스템은 왜 나오게 되었을까요?

- 소프트웨어 형상관리는 SW 개발 및 보수유지 과정에서 발생하는 소스코드, 문서, 인터페이스 등 각종 결과물에 대해 형상을 만들고, 이들 형상에 대한 변경을 체계적으로 관리, 제어하기 위한 활동을 의미합니다.

  - 팀원들과의 협업이 어렵다!
    - 실제로 이 글을 쓰고있는 저도 첫 프로젝트를 zip 파일을 공유하는 방식으로 진행을 했었습니다. 이 때 이야기없이 나의 코드를 변경하거나, 다른 사람의 코드에서 에러가 나면 찾는데 정말 오랜시간을 썼던 것 같아요! :(
  - 삭제된 파일을 찾을 수 없어!
    - 수정중이던 파일을 삭제했다고 가정해봅시다. 깃을 사용하게 되면, 내가 개발했던 내용을 저장 & 찾아올 수 있지만, 로컬환경에서 없어진 파일은 되돌릴 수 없죠!

  <br/>

## 2. 분산 버전 관리 시스템.

- 중앙 집중식
  - 모든 데이터를 중앙 서버 한 곳에서 저장을 해두는 방식입니다.
  - 데이터가 하나의 서버에 저장이 되어있어서, 연결과 전송이 느리고 데이터가 유실될 가능성이 높습니다.
    <br/><br/>
- 분산 버전식
  - 중앙 집중식의 문제점을 극복 하기 위하여 등장한 방식으로, 저장소 자체를 받아오는 방식을 의미한다.
  - 서버와의 통신없이, 로컬에서 작업을 하고 git command를 통해 변경사항을 업로드하고 git이 변경이력을 추적해줌으로써 나와 팀원의 진행상황을 한 눈에 볼 수 있다.

<br/>

## 3. git vs github

- git

  - 현재 진행중인 프로젝트를 공유, 백업, 관리하는 버전관리 소프트웨어입니다.
  - 로컬시스템에 설치되고 관리가 되기 때문에 네트워크 통신이 없이도 작동합니다.
  - 현재 폴더에서 커맨드를 킨 뒤, git init을 입력하면 .git 파일이 생겨나는데 이 파일 내부에서 변경 이력들이 관리됩니다.
  - 깃허브에 올리기 전에 로컬에서 커밋을 했다고 하더라도, .git파일을 포함하고 있는 폴더를 삭제하는 경우 되돌릴 수 없습니다!

  <br/>

- github
  - git은 버전관리를 위한 소프트웨어라면, github는 git 이력을 볼 수 있도록 만들어둔 서비스입니다.
  - 비유를 해보자면 git은 편집된 영상이고, github는 그 영상들을 올릴 수 있는 유튜브라고 생각하시면 될 것 같습니다 :)

<br/>

## 4. git의 명령어들

<br>

- git file의 생명주기(life cycle)

  - File은 총 4가지 상태 [Untracked, UnModifed, Modified, Staged] 로 나뉩니다.
  - Untracked
    - 로컬에 생성된파일이지만, 깃으로 버전관리가 되고있지 않은 상태를 의미합니다.
  - UnModified
    - 신규 파일이 추가됬을 때의 상태를 의미합니다. (git add 된 상태)
  - Modified
    - add된 파일이 변경 되었을 때의 상태를 의미합니다. (file Changed)
  - Staged
    - Staging Area에 반영된 상태.
  - Staging Area가 필요한 이유
    - 임시 저장공간인 Staging이 없으면 Commit을 나누어 보내거나 충돌을 해결해야하는 경우에 어려움을 겪는다.

- git add

  - add 명령어는 커밋을 할 파일들을, 저장하는 방식입니다.
  - 저장이 되었다는 것은 Staging Area에 올라갔다는 것을 의미합니다.
    <br/><br/>

  ```
  // 변경이 된 모든 파일을 staging 합니다.
  git add .

  // 특정 파일만 staging 합니다.
  git add 'fileName'
  ```

  <br/>

- git commit

  - git add를 통해 staging된 파일들을 Repository로 옮기는 명령어입니다.
  - Repository로 가게되면, 깃을 통해 변경사항을 추적할 수 있습니다.
    <br/><br/>

  ```
  // 어떤 작업을 한건지 커밋 메세지를 남기며 레포지터리로 옮깁니다.
  // -m은 메세지의 약자이며, "" 내부에는 남기고 싶은 메세지를 입력합니다.
  git commit -m "commit message"

  // 예시
  git commit -m "첫 번째 커밋"

  // 아래와 같이 관련된 커밋 컨벤션이 있으니 추가적으로 공부해보시면 좋을 것 같습니다 :)
  git commit -m "feat: 로그인 validation 추가"
  ```

  <br/>

- git push

  - commit을 통해 레포지터리에 올라온 파일들을, 원격 저장소로 전송합니다.
    <br/><br/>

  ```
  git push
  ```

- git pull
  - 원격 저장소의 변경사항을 로컬로 가져와서 merge 하는 행위를 의마합니다.
    <br/> (=> pull === fetch[변경 사항을 가져옴] + merge(변경사항을 적용))

<br/>

- git branch

  - 깃에서는 작업을 여러 개의 가지로 나누어 작업할 수있는데, 현재 존재하는 트리를 보기위한 명령어이다.
    <br/><br/>

  ```
    // 브랜치 목록을 불러옵니다.
    git branch

    // 브랜치를 생성하고, 즉시 이동합니다.
    git checkout -b 'newBranchName'

    // 이미 존재하는 브랜치로 이동합니다.
    git checkout 'alreadyExistBranch'
  ```

- git stash

  - 다른 브랜치로 이동하기 위해서는, 현재 add된 작업들이 모두 commit이 된 상태일 때만 가능합니다.
  - 이러한 불편함을 간소화 하기 위하여, stash를 통해 현재 작업을 임시 저장소에 저장한 뒤 브랜치를 이동할 수 있습니다.

    ```
    // 아래의 두 명령어는 같은 동작을 수행합니다.
    git stash
    git stash save

    // stash한 목록을 확인합니다.
    git stash list

    // 가장 최근에 stash된 작업을 가져옵니다.
    git stash apply

    // 특정 stash를 가져옵니다.
    git stash apply 'stash name'

    // stash 기록을 제거합니다.
    git stash drop || git stash drop 'stashName'

    // 삭제된 stash를 되돌립니다.
    git stash sow -p | git apply -R
    ```

## 5. git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요?

- git은 데이터를 key, value 쌍인 Object로 관리합니다.
- git의 Head는 커밋을 가리키는 포인터와 같은 역할을 수행합니다.
  - master는 현재의 커밋의 값을 저장하고, HEAD는 마스터 브랜치를 가리키는 포인터입니다.
- git의 Branch는 작업 트리를 나타냅니다.
- git의 Tag는 작업 이력의 특정 부분에 표시를 해두고 이동하는 용도로 사용된다.
  - Tag를 통해 이동해도, 수정은 불가능하다. 그 이유는 보통 태그는 배포가 되었다는 정보를 가지고 있는데 본 정보가 수정되는 경우 버전관리에 차질이 생기기 때문이다.\

<br>

## 6. 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?

- git reset [--hard | --soft]를 사용하거나 git revert를 사용합니다.
